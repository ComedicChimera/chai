# Package Definitions
Package definitions are going to be the principle way to structure Chai code: they are going to replace the idea of "modules" and the necessity of a separate module file.

As a review, Chai projects are comprised of **packages** which contain some number of **files** which all share a common namespace.  This system works fine in isolation with no "in source text" modifications to user source code. 

However, we need a robust but simple way to perform import resolution.  My philosophy has always been the Chai imports should be "well-defined" that is to say that on any system, executing the compiler from anywhere, the result of import resolution should always be the same provided the same packages are visible to the compiler.  

My initial approach to this was to require a module file which would act as a sort of "root" from which all imports would be performed.  There are many problems with this approach however:

1. It requires an extra file to be created before any project can begin.
2. It causes too much overlap between the compiler's responsibilities and those of a build tool.
3. It requires additional libraries to parse the module file which only adds more difficulty to the process of bootstrapping.
4. It means that only "modules" can be compiled which makes Chai less approachable.

So, how do we fix this?  The solution I have come up with is to introduce a **package definition**: a little snippet of code that goes at the top of every file that "places" a package within the import hierarchy.  

## Syntax
The syntax for a package definition is very simple:

```
pkg_def := 'package' pkg_path
```

Here are some examples of that syntax:

```
package hello

package io.std

package core.types
```

Although this does require a little bit of code to be inserted at the top of the file, this small sacrifice is acceptable because:

1. It can often be automatically generated by editors.
2. It is a common trade-off that many languages make that doesn't have even close to the power of Chai's system (as we will see later).

## Semantics
The idea of these definitions is that the package path defined by the definition places the package relative to a particular root.  

For example, in the package definition,

```
package io.std
```

This defines the "root" for the given package as the `io` package which is up a directory from the current package `std`.  So, when Chai is resolve import statements within the `std` package it resolves relative to (and with the *exposes* of) the `io` package.

For example, to import the `fs` package from inside `std`, you would use:

```
import io.fs
```

This system is fairly straight-forward and easy to understand.  But, it does come with some restrictions:

Firstly, the package path must match the directory structure.  For example, if you had the structure:

```
a/
	b/
	c/
		d/
```

The package definitions for `d` could only be:

```
package d

package c.d

package a.c.d
```

This restriction is inline with how imports are actually resolved: the name of the package is always considered to be the name of the directory.

The second restriction is that all the files within the same package must have the same package definition.  The implications and logic behind this restriction should be obvious.

## Exposing Foreign Packages
One caveat of this package system is that you can't import from outside of your root package.  For example, if the package `d` had the package definition: `c.d` then it couldn't import `b`.  

This problem is also more general: how do you import shared packages or even standard library packages?

The answer is the concept of **exposing** which will introduce here.  Basically, all packages which share the same root share a common list of **exposes** which are the additional packages that are made visible to all the packages within that root.  

By default, all of the standard packages (that is the packages in the `lib/std` directory) are exposed for all packages.

You add exposes to a given package using a special compiler flag: `-e, --exposes`.

Here is the syntax for that flag:

```
[expose-path]:[visible-name]=@[location-root]/[path],...;...
```

The `expose-path` value is how you specify what package you are exposing.  The package being built always has the path `root`.  All packages exposed to the `root` package can be accessed by appending `.` followed by their defined visible name in `root` and so on for packages of visible packages.

The `location-root` value is the "root" value to seach for the package in.  It has one of the following values:

- `global` - search in the global (public) package directory
- `local` - seach relative to the package being assigned to
- `std` - search in the standard package directory (used to rename standard packages)
- `abs` - search using an absolute path

Here is an example usage of this flag:

```
-e="root:llvm=@global/github.com/llvm-project/llvm,toml=@global/github.com/github-user/chai-toml;root.toml:parseutil=@abs/C:/chai-libs/parse-util"
```

Obviously, this flag's syntax is quite opaque and a bit difficult to understand, not to mention that is requires quite a bit of typing.  The intention is for this flag's value to be generating using a build tool like `kettle` -- for large projects, the user should rarely be calling the compiler directly.